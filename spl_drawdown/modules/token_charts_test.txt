import json
from dataclasses import asdict
from datetime import datetime, timedelta, timezone
from time import sleep
from typing import List

import numpy as np
import pandas as pd
import requests

from spl_drawdown.types.candle_data import CandleData
from spl_drawdown.types.token_data import TokenData
from spl_drawdown.utils.log import get_logger

logger = get_logger()


class TokenCharts:
    def __init__(self, BIRDEYE_API_TOKEN: str):
        self.BIRDEYE_API_TOKEN = BIRDEYE_API_TOKEN
        self.headers = {"accept": "application/json", "x-chain": "solana", "X-API-KEY": self.BIRDEYE_API_TOKEN}

    def set_token_list(self, token_list: List[TokenData] = None):
        self.token_list = token_list

    def run(self):
        """Populates self.token_list: List[TokenData]"""
        while True:
            print('-------------------------------------------------')
            self.populate_candle_data()
            self._print_data()
            self.populate_candle_data2()
            self._print_data()

            current_time = datetime.now(timezone.utc)
            if current_time.minute < 20 or current_time.minute >= 58:
                sleep(60)
            else:
                sleep_time = (60 - current_time.minute) * 60
                logger.info("sleeping for {x}".format(x=sleep_time))
                sleep(sleep_time)

    def populate_candle_data(self, candle_days: int = 14) -> List[TokenData]:
        """_summary_

            NOTE: Timestamp for candle is the beginning of the time period
        Args:
            token (TokenData): _description_
            filter_days (int, optional): _description_. Defaults to 14.
        """
        current_time = datetime.now(timezone.utc).replace(minute=0, second=0, microsecond=0)
        utc_from = current_time - timedelta(hours=candle_days * 24)

        for token in self.token_list:
            token.candle_data = list()
            token.candle_data = self.get_candle_data(
                mint_address=token.mint_address, start_date=utc_from, end_date=current_time, interval_minutes=60
            )

    def get_candle_data(
        self, mint_address: str, start_date: datetime, end_date: datetime, interval_minutes: int
    ) -> List[CandleData]:
        """_summary_

        Args:
            start_date (datetime): _description_
            end_date (datetime): _description_
            interval_minutes (int): _description_

        Returns:
            List[CandleData]: _description_
        """
        end_date_unix = int(end_date.timestamp())

        temp_end_time = start_date
        results = []
        while temp_end_time < end_date:
            temp_end_time = min(start_date + timedelta(minutes=interval_minutes * 99), end_date)

            time_from = int(start_date.timestamp())
            time_to = int(temp_end_time.timestamp())

            params = {
                "address": mint_address,
                "type": "1H",
                "currency": "usd",
                "time_from": time_from,
                "time_to": time_to,
            }
            logger.info(
                "Calling chart for v3 {s} From: {f} To: {t}".format(s=mint_address, f=start_date, t=temp_end_time)
            )
            logger.info(params)
            url = "https://public-api.birdeye.so/defi/v3/ohlcv"
            response = requests.get(url, headers=self.headers, params=params)

            # Check if the request was successful
            if response.status_code != 200:
                logger.info("Response failed for {t}: {e}".format(t=mint_address, e=response.text))
                return results

            # Parse the JSON response
            response_json = json.loads(response.text)

            if "data" not in response_json or "items" not in response_json["data"]:
                logger.info("No OCLHV data for {t}: {e}".format(t=mint_address, e=response_json))
                return results

            for each in response_json["data"]["items"]:
                dt = datetime.fromtimestamp(each["unix_time"])
                date_string = dt.strftime("%Y-%m-%d %H:%M:%S")
                if each["unix_time"] == end_date_unix:
                    continue
                if date_string not in [x.time_str for x in results]:
                    results.append(
                        CandleData(
                            time=dt,
                            time_str=date_string,
                            time_unix=each["unix_time"],
                            open=each["o"],
                            high=each["h"],
                            low=each["l"],
                            close=each["c"],
                            volume=round(each["v_usd"], 0),
                        )
                    )
            start_date = temp_end_time + timedelta(minutes=interval_minutes)

        return results

    def populate_candle_data2(self, candle_days: int = 14) -> List[TokenData]:
        """_summary_

            NOTE: Timestamp for candle is the beginning of the time period
        Args:
            token (TokenData): _description_
            filter_days (int, optional): _description_. Defaults to 14.
        """
        current_time = datetime.now(timezone.utc).replace(minute=0, second=0, microsecond=0)
        utc_from = current_time - timedelta(hours=candle_days * 24)

        for token in self.token_list:
            token.candle_data = list()
            token.candle_data = self.get_candle_data2(
                mint_address=token.mint_address, start_date=utc_from, end_date=current_time, interval_minutes=60
            )

    def get_candle_data2(
        self, mint_address: str, start_date: datetime, end_date: datetime, interval_minutes: int
    ) -> List[CandleData]:
        """_summary_

        Args:
            start_date (datetime): _description_
            end_date (datetime): _description_
            interval_minutes (int): _description_

        Returns:
            List[CandleData]: _description_
        """
        end_date_unix = int(end_date.timestamp())

        temp_end_time = start_date
        results = []
        while temp_end_time < end_date:
            temp_end_time = min(start_date + timedelta(minutes=interval_minutes * 99), end_date)

            time_from = int(start_date.timestamp())
            time_to = int(temp_end_time.timestamp())

            params = {
                "address": mint_address,
                "type": "1H",
                "currency": "usd",
                "time_from": time_from,
                "time_to": time_to,
            }
            logger.info(
                "Calling chart for v0 {s} From: {f} To: {t}".format(s=mint_address, f=start_date, t=temp_end_time)
            )
            logger.info(params)
            url = "https://public-api.birdeye.so/defi/ohlcv"
            response = requests.get(url, headers=self.headers, params=params)

            # Check if the request was successful
            if response.status_code != 200:
                logger.info("Response failed for {t}: {e}".format(t=mint_address, e=response.text))
                return results

            # Parse the JSON response
            response_json = json.loads(response.text)

            if "data" not in response_json or "items" not in response_json["data"]:
                logger.info("No OCLHV data for {t}: {e}".format(t=mint_address, e=response_json))
                return results

            for each in response_json["data"]["items"]:
                dt = datetime.fromtimestamp(each["unixTime"])
                date_string = dt.strftime("%Y-%m-%d %H:%M:%S")
                if each["unixTime"] == end_date_unix:
                    continue
                if date_string not in [x.time_str for x in results]:
                    results.append(
                        CandleData(
                            time=dt,
                            time_str=date_string,
                            time_unix=each["unixTime"],
                            open=each["o"],
                            high=each["h"],
                            low=each["l"],
                            close=each["c"],
                            volume=round(each["v"], 0),
                        )
                    )
            start_date = temp_end_time + timedelta(minutes=interval_minutes)

        return results

    def _print_data(self):
        for each in self.token_list:
            print_token_dict = asdict(each)
            print_token_dict.pop("candle_data", None)
            print_token_dict["candle_len"] = len(each.candle_data)
            df = pd.DataFrame([print_token_dict])
            logger.info(f"\n{df.to_string()}")

            df = pd.DataFrame(each.candle_data[-3:])
            df = df.drop(columns=["time_str", "time_unix"], errors="ignore")
            logger.info(f"\n{df.to_string()}")
            logger.info("-------------------------------")


if __name__ == "__main__":
    import os

    from dotenv import load_dotenv

    load_dotenv()
    BIRDEYE_API_TOKEN = os.environ.get("BIRDEYE_API_TOKEN")

    S = TokenCharts(BIRDEYE_API_TOKEN=BIRDEYE_API_TOKEN)
    token_list = [
        TokenData(name="FARTCOIN", symbol="FARTCOIN", mint_address="GHichsGq8aPnqJyz6Jp1ASTK4PNLpB5KrD6XrfDjpump")
    ]
    S.set_token_list(token_list=token_list)
    S.run()
